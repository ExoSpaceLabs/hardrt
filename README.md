# ğŸ«€ HardRT [[ExoSpaceLabs](https://github.com/ExoSpaceLabs)]

**HardRT** is the heartbeat of small embedded systems.  
A tiny, portable, modular real-time operating system written in C.  
Minimal footprint, predictable behavior, and zero hardware dependencies in its core.

**Version:** `0.3.0`

---

## âœ¨ Features
- **Pure C core** â€” no dynamic allocation, no HAL dependencies.
- **Portable ports** â€” currently: null, posix, cortex-m.
- **Scheduler** â€” priority, round-robin, or hybrid; RR currently rotates on yield/sleep.
- **Binary semaphores** â€” blocking take, `try_take`, ISR-safe `give` with FIFO wake-up.
- **Static tasks** â€” stacks and TCBS supplied by the application.
- **CMake package** â€” install and consume via `find_package(HardRT)`.
- **Generated metadata** â€” version and port headers at build time.
- **Optional C++17 wrapper** â€” header-only interface target when enabled (WIP).

> The POSIX port is for logic verification, not timing accuracy. ucontext is used and supported on Linux/glibc.

> â€œOn Cortex-M, the max time from tick to running the next highest priority ready task is bounded by: ISR tail + PendSV latency + context save/restoreâ€

> The C++17 wrapper is not yet implemented. It shall be provided in future releases

---

### Architecture

![architecture](docs/images/Architecture.png)

The Architecture is mainly divided into three layers:
- **Application Layer**: Where the tasks are defined. e.g., camera, UART downlink, HK/FDIR, etc.
- **HardRT Core**: Where the RTOS lives, manages tasks, and calls the port to switch context when necessary.
  - **HardRT Port**: Wraps the hardware-specific methods.
- **Hardware Layer**: Hardware specific methods, registers, primitives, etc.

### Task State Machine
![task_state_machine.png](docs/images/task_state_machine.png)

Where each task is executed in accordance with the policy adopted by the scheduler.

> Note: If a task exits, it will yield forever.

see also [Concepts](#-concepts)

## ğŸ“ Repository Layout
```
hardrt/
â”œâ”€â”€ inc/                    # Public headers
â”œâ”€â”€ src/                    # Core + port implementations
â”‚   â”œâ”€â”€ core/               # Kernel internals
â”‚   â””â”€â”€ port/               # Architecture-specific backends (null, posix, cortex_m)
â”œâ”€â”€ cpp/                    # Optional C++17 interface (WIP)
â”œâ”€â”€ cmake/                  # additional cmake files and toolchains
â”œâ”€â”€ examples/               # Example applications
â”œâ”€â”€ tests/                  # POSIX test harness
â”œâ”€â”€ scripts/                # scripts to build and test the project
â”œâ”€â”€ docs/                   # Documentation
â”œâ”€â”€ LICENSE
â””â”€â”€ README.md
```

---

## âš™ï¸ Build
```bash
mkdir -p build && cd build
cmake -DHARDRT_PORT=posix -DHARDRT_BUILD_EXAMPLES=ON ..
cmake --build . -j$(nproc)
./examples/two_tasks/two_tasks
```
Install package:
```bash
cmake --install . --prefix "$PWD/install"
```

Consume from another CMake project:
```cmake
find_package(HardRT 0.2.0 REQUIRED)
add_executable(app main.c)
target_link_libraries(app PRIVATE HardRT::hardrt)
```
For further information and CMake flags, see the [Build](docs/BUILD.md) document.

---

## ğŸ§  Concepts

### Tick vs Timeslice
- **Tick:** base time unit generated by a timer interrupt (or POSIX signal). HardRT increments a counter each tick and wakes sleepers.
- **Timeslice:** number of ticks a task may run before being rotated under RR. In v0.3.0, rotation happens on yield/sleep; strict preemption at the slice end is planned.

### Semaphores (binary)
- `hrt_sem_init`, `hrt_sem_take`, `hrt_sem_try_take`, `hrt_sem_give`, `hrt_sem_give_from_isr`.
- Use as a mutex substitute or an event signal. For mutex-like use, enabling immediate handoff on give is recommended (see roadmap).

### Scheduling Flow
![scheduling_flow.png](docs/images/scheduling_flow.png)

Tick (ISR/signal) -> hrt_tick_from_isr():
- g_tick++
- wake any SLEEP tasks whose wake_tick â‡ now
- hrt__pend_context_switch() (set resched flag)

Scheduler loop (port):
- if resched flag:
  -  next = hrt__pick_next_ready()
  -  swapcontext/PendSV to next task

Task-level yield/sleep:
- mark state (READYâ†’queue or SLEEP)
- hrt__pend_context_switch()
- hrt_port_yield_to_scheduler() (safe handoff from task ctx)


---


## ğŸ“œ License
Apache License 2.0 â€” see [LICENSE](LICENSE).
